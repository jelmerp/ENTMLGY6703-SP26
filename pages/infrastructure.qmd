---
title: "Computational Infrastructure<br>for Genomics Analyses"
subtitle: "Week 3 lab -- part 1"
pagetitle: "Computational Infrastructure"
date: 2026-01-30
author:
  - name: Jelmer Poelstra
    orcid: 0000-0002-3514-7462
    email: poelstra.1@osu.edu
    affiliation: 
      - name: CFAES Bioinformatics Core, Ohio State University
        url: https://mcic.osu.edu/bioinformatics
other-links:
  - text: "Week 3 lecture"
    icon: bookmarks
    href: sequencing.html
  - text: "Week 3 lab - part 2"
    icon: pencil
    href: data.html
bibliography: ../references.bib
---

-----

<br>

## Introduction

### Today's lab

- You will first learn about a typical "computational infrastructure"
  to analyze high-throughput sequencing (HTS) data -- **this page, part I**.

- You will then use that infrastructure to start the exploration of an HTS dataset.
  You'll check out HTS read and reference genome files,
  and perform read quality control -- [**part II**](data.qmd).

### Goals for this part

- Learn what a typical computational infrastructure for genomics analyses looks like
- Learn the basics of supercomputers, and using the Ohio Supercomputer Center (OSC)
- Become familiar with a text editor (VS Code)
- Take your first steps in the command-line interface of the Unix shell

## Computational infrastructure overview

Due in large part to the amount of data involved,
a laptop or desktop computer is often not sufficient to work with HTS data.
Additionally, most of the specialized programs that help you analyze your data
can only be run through a "command-line interface",
in which you type commands rather than point-and-click.

For these reasons,
a typical computational infrastructure -the computer hardware and software-
to do genomics analyses involves:

1.  A **supercomputer**[^1] -- in our case, the Ohio Supercomputer Center (OSC)
2.  A **text editor** -- in our case, VS Code
3.  The **Unix shell** (terminal) and command-line programs that run in it
4.  **R** (or perhaps Python) for statistical analysis and visualization.

[^1]: Cloud computing is an alternative, but won't be covered here.

Today, you will see the first three of these components in action.
In this first part, you'll get a little familiar with them,
and in [the next part](./data.qmd),
you'll apply what you learned to reference genome and HTS read data.
(In next week's lab,
we will cover the fourth item in the context of RNA-Seq differential expression
analysis.)

::: {.callout-warning collapse="true"}
#### Side note: "I don't think I like coding. Can I avoid all of this?" *(Click to expand)*

If you will often be doing HTS/genomics projects like the ones mentioned above,
it's hard to avoid using this (kind of) infrastructure.
But especially if you're only doing a single project like this,
you might avoid it by:

- Outsourcing part of the analysis:
  companies or service cores can often do the more standardized,
  compute-heavy parts for you
- Trying a platform like [***Galaxy***](https://usegalaxy.org),
  which has a web browser interface and doesn't require coding

Finally, generative AI tools are becoming increasingly capable of
writing code for you based on your instructions,
and may spurn additional no-code or low-code solutions in the future.
:::

## The Ohio Supercomputer Center (OSC)

### Introduction to supercomputers

A **supercomputer** (also known as a "**cluster**")
consists of many computers that are connected by a high-speed network,
and can be accessed remotely by its users.
You can think of it simply as a *network of computers* ---
with individual computers called "**nodes**".

Supercomputers provide two main types of resources:

- **Compute**: computing power to run your data processing and analysis
- **File storage**: space for storage of your data and results

Why might you need a supercomputer?

- Often, your HTS **dataset is too large** to be handled efficiently,
  or at all, by a laptop/desktop computer
- To **speed up** analyses by using more computing power and/or
  running them in parallel
- It's also a great place to **store** large amounts of data ---
  and genomics data is often very large

### Introduction to OSC

![](../img/osc_logo.png){fig-align="center" width="65%" fig-alt="The Ohio Supercomputer Center logo." .lightbox}

The **Ohio Supercomputer Center (OSC)** provides computing resources to researchers
and others across Ohio.
Research usage is charged at subsidized rates, and in our case at CFAES,
these costs are absorbed at the college level.

This is what "Cardinal", one of the OSC supercomputers, physically looks like:

![_The Cardinal OSC cluster: it's just some cabinets with many connected computers inside!_](../img/cardinal_photo.jpeg){fig-align="center" width="55%" fig-alt="A photo of the Cardinal OSC cluster" .lightbox}

#### The structure of an OSC supercomputer

You can think of a supercomputer as having three main parts:

- **Login Nodes**: The handful of computers users end up on after logging in
- **Compute Nodes**: The many computers you can reserve to run your analyses
- **File Systems**: Where files are stored (these are shared between the OSC clusters)

![_The structure of a supercomputer with three main components: file systems, login nodes, and compute nodes_ ](../img/cluster_overview_ed.png){fig-align="center" width="85%" fig-alt="A diagram showing the structure of a supercomputer with three main components: file systems, login nodes, and compute nodes" .lightbox}

### The OSC OnDemand web portal

{{< fa user-edit >}} Go to <https://ondemand.osc.edu> and use the
username + password login option on the left-hand side to log in with your OSC
(not OSU!) credentials.

Once logged in, you should see a landing page similar to the one below:

![_The OSC OnDemand landing page_](../img/ondemand_home.png){fig-align="center" width="95%" fig-alt="A screenshot of the OSC OnDemand landing page" .lightbox}

We will now go through some of the dropdown menus in the **blue bar along the top**.

#### Files menu

Hovering over the **Files** dropdown menu gives a list of folders you have access to.
If your account is brand new, you should only see three listed:

1. A **Home** folder for miscellaneous personal files (starts with `/users/`)
2. The `PAS2880` project's "**project**" folder for permanent storage (`/fs/ess/PAS2880`)
3. The `PAS2880` project's "**scratch**" folder for temporary storage (`/fs/scratch/PAS2880`) 

{{< fa user-edit >}} Click on the `PAS2880` scratch folder, `/fs/scratch/PAS2880`.
You should see the folders and files present there, 
and click on folders to explore their contents.
Click on the `ENT6703` folder, which we'll be using for these labs,
and you should see the following:

![_The OnDemand file browser_](../img/ondemand_files_PAS2880.png){fig-align="center" width="95%" fig-alt="A screenshot of the OSC OnDemand file browser." .lightbox}

This interface is **much like the file browser on your own computer**,
so you can create, delete, move, copy files and folders.
Additionally, you can upload (from your computer to OSC) and download
(from OSC your computer) files -- see the buttons across the top.

{{< fa user-edit >}} **Create your own folder** by clicking the `New Directory`
button at the top.
Give it the *exact same name as your OSC username*,
including any capitalization.
_(I'll refer to this folder as your **personal folder** from now on.)_

::: {.callout-tip appearance="simple"}
*If in doubt, you can see what your username is by looking at the right side of the blue top bar:*

![](../img/username.png){fig-align="center" width="40%"}
:::

::: exercise
#### {{< fa user-edit >}} Exercise: Understanding file/folder locations

1. Click on your personal folder to enter it.

2. Take a look at the so-called "**path**" (file/folder location) shown at the top
   of the file browser, next to "Change directory".
   How do you interpret this notation:
   what do the forward slashes <kbd>/</kbd> indicate,
   and what does each part in between represent?
   You can click back-and-forth to see how the path changes.
   
   <details><summary>*Click for the solution*</summary>
   The forward slashes <kbd>/</kbd> separate folder in a path.
   Each part in between represents a folder name.
   For example, in `/fs/scratch/PAS2880/ENT6703`:
   
   - `/fs` is a top-level folder -- you can always distinguish a top-level folder
     because the path starts with a forward slash <kbd>/</kbd>
   - inside that is the `scratch` folder
   - inside that is the `PAS2880` folder
   - inside that is the `ENT6703` folder
   
   Taking a step back, the OSC file system is a single hierarchical structure.
   File systems on personal computers are structured very similarly,
   though in Windows, among some other differences,
   backslashes <kbd>\</kbd> are used instead of forward slashes <kbd>/</kbd>.
   
   </details>
   
   <details><summary>*Click to see a diagram of the OSC file system*</summary>
   <hr style="height:1pt; visibility:hidden;" />
   ![](../img/paths2.png){fig-align="center" width="60%" fig-alt="A diagram showing the hierarchical structure of a file system with folders and subfolders." .lightbox}
   </details>
   
3. If user `miranda` made a folder inside the `ENT6703` folder,
   what would be the path to that folder?
   
   <details><summary>*Click for the solution*</summary>
   The path would be `/fs/scratch/PAS2880/ENT6703/miranda`.
   </details>
:::

::: {.callout-note collapse="true"}
#### Side note: OSC System Status overview*(click to expand)*

In the "**Clusters**" dropdown menu,
click on the item at the bottom, "**`System Status`**":

![_The Clusters dropdown menu_](../img/ondemand_systemstatus_select.png){fig-align="center" width="40%" fig-alt="A screenshot of the options in the OSC OnDemand Clusters dropdown menu." .lightbox}

This page shows an overview of the live, current usage of the two clusters --
just to give you an idea of the scale of the supercomputer center and its usage.

![A screenshot of the "System Status" page showing live cluster usage.](../img/ondemand_systemstatus.png){fig-align="center" width="90%" fig-alt="A screenshot of the OSC Ondemand System Status page showing live cluster usage." .lightbox}
:::

#### Interactive Apps

You can access a bunch of software via the **Interactive Apps** dropdown menu --
go ahead and click on the "Code Server" button --
that will allow us to use the VS Code text editor on OSC, as explained below.

![](../img/ondemand_vscode_select.png){fig-align="center" width="24%" fig-alt="A screenshot of the options in the OSC OnDemand Interactive Apps dropdown menu." .lightbox}

## The VS Code text editor

### What is VS Code?

VS Code is basically a fancy text editor,
with an integrated terminal that runs a Unix shell.
In these labs:

- VS Code will be our editor for Unix shell code (this week)
- RStudio will be our editor for R (next week's lab)

### Starting a VS Code session

Interactive Apps like VS Code and RStudio **run on compute nodes** (not login nodes).
Because compute nodes always need to be "reserved" to be used,
you have to fill out a form and specify the following details:

- The **Cluster** we want to use: `pitzer`
- The **Account**, the OSC Project to be billed for the compute node usage: `PAS2880`
- The **Number of hours** we want to make a reservation for: `4`
- The **Working Directory** (starting point) for the program:
  `/fs/scratch/PAS2880/ENT6703`
- [The **App Code Server version**: `4.8.3` (this should be the only available option)]{style="color:#969696"}

![This is how you should fill out the form to start a VS Code session](../img/ondemand_vscode_form.png){fig-align="center" width="65%" fig-alt="A screenshot of OSC OnDemand VS Code form." .lightbox}

Click `Launch` and you'll be sent to the _My Interactive Sessions_ page
with a card for your job at the top.
First, your job may be *Queued* for some seconds
(i.e., waiting for computing resources to be assigned to it),
but it should soon switch to *Starting* and then to *Running*:
  
![](../img/ondemand_vscode_running2.png){fig-align="center" width="75%" fig-alt="A screenshot of the OSC OnDemand page shown when the Code Server job has started running." .lightbox}

Once the blue **Connect to VS Code** button appears,
click that and VS Code will open in a new browser tab.
When VS Code opens, you may get these two pop-ups (and possibly some others):

::: columns
::: {.column width="52%"}
![Here, click "Yes, ..." and check the "Trust" box](../img/vscode-trust2.png){fig-align="center" width="85%" fig-alt="A screenshot of a popup you may get when first opening a folder in VS Code." .lightbox}
:::

::: {.column width="48%"}
![Here, click "Don't Show Again"](../img/vscode-git.png){fig-align="center" width="85%" fig-alt="A screenshot of a popup you may get when first opening VS Code." .lightbox}
:::
:::

### The VS Code User Interface

![An annotated overview of the VS Code User Interface](../img/vscode-welcome_ed.png){fig-align="center" width="80%" fig-alt="An annotated screenshot of the VS Code user interace" .lightbox}

#### Editor pane and "Get Started" document

The main part of the VS Code is the **editor pane**.
Here, you can open files like scripts and other types of text files, and images.
Right now, you should see a Get Started page --
you don't have to go through any steps that may be suggested there.
  
#### Side bars

The **Activity Bar** (narrow side bar) on the far left has:

- A {{< fa bars >}} ("hamburger menu"),
  which has menu items like `File` that you often find in a top bar
- A {{< fa cog >}} (cog wheel icon) in the bottom,
  through which you can mainly access *settings*
- Icons to toggle **(wide) Side Bar** options --
  but we'll only use the default selection, the *Explorer* (file browser)

#### Terminal (with a Unix shell)

**Open a terminal** by clicking  {{< fa bars >}}   =\> `Terminal` =\> `New Terminal`.
We'll start using this in the next section!

::: exercise
#### {{< fa user-edit >}} Exercise: Try a few color themes

1.  Access the "Color Themes" option by clicking <i class="fa fa-cog"></i>   =\> `Color Theme`.
2.  Try out a few themes and see what you like!
:::

## The Unix shell

### What is the Unix shell and why use it?

A computer's **shell** is an interface inside a Terminal window that allows you
to interact with your computer by typing commands.
More specifically,
the **Unix shell** is the shell of Unix-based operating systems,
which include Mac and Linux (but not Windows).
Supercomputers like OSC run on Linux,
so the default shell here -and for scientific computing in general- is a Unix shell.

Using the Unix shell is often a necessity when working with HTS data,
in order to run the **specialized software** needed for data processing.
But there are other good reasons to use the shell, including:

- **Automation and efficiency**\
  The shell allows you to repeat and automate tasks easily and without
  introducing errors.
- **Reproducibility**\
  When working in the shell,
  it's straightforward to keep a detailed record of what you have done.
- **Viewing and processing large files**\
  Shell commands are excellent at viewing and processing
  _large, plain-text files_, which are common in omics data.
  
### First steps in the Unix shell

#### The shell prompt

Inside your terminal, the "prompt" indicates that the shell is ready for a command.
Your prompt at OSC should show the following pieces of information:

`[<username>@<node-name> <current-folder>]$`

For example, below, user `jelmer` is on node `p0080` in folder `ENT6703`:

``` bash-in-nocolor
[jelmer@p0080 ENT6703]$ 
```

You type commands **after the dollar sign** `$`,
and then press <kbd>Enter</kbd> to execute them.
When it has finished executing,
you'll get your prompt back and can type a new command.

::: callout-tip
#### How shell code is shown on this website

- The **pale gray boxes** like the ones shown above are used to show the commands
  you should type.
- From now on, the prompt itself (`[...]$`) won't be shown,
  only the commands you type.
  This saves space and allows you to copy-paste code from the boxes
  (but I recommend typing!).
- **Darker gray boxes** (with italic text, below the boxes with commands)
  show the *output* of commands.
:::

#### A few simple commands: `date`, `whoami`, `pwd`

The Unix shell comes with hundreds of "commands":
small programs that perform specific actions.
(If you're familiar with R or Python, a Unix command is like an R/Python function.)
Let's start with a few simple commands:

- The `date` command prints the current date and time:

  ```bash
  date
  ```
  ```bash-out
  Fri Jan 26 14:31:51 EST 2024
  ```

- The `whoami` (who-am-i) command prints your username:

  ```bash
  whoami
  ```
  ```bash-out
  jelmer
  ```

- The `pwd` -Print Working Directory- command prints the "path" (location) of
  the folder you are currently located in:

  ```bash
  pwd
  ```
  ``` bash-out
  /fs/scratch/PAS2880/ENT6703/jelmer
  ```

All those commands provided us with some output.
That output was **printed to screen**,
which is the default behavior for nearly every Unix command.

::: callout-note
#### Some terminology

- Recall that "directory" / "dir" is just a synonym for "folder" --
  we'll use "**dir**" from now on
- When working in a Unix shell, you are always "in" a specific directory,
  which is called your **working dir**
- Recall from earlier that a "**path**", such as that output by `pwd`,
  specifies the location of a file or dir in a computer's file system
:::

### `cd` and command actions & arguments

In the above three examples:

- You merely typed a command and nothing else
- The command provided some information, which was printed to screen

But many commands perform an **action** other than providing information.
For example, you can use the command **`cd`** to Change Directory,
i.e. change your working dir.

Let's use `cd` to move to another dir by specifying the *path*
to that directory after the `cd` command:

```bash
cd /fs/scratch/PAS2880/ENT6703/share
```

Note that `cd` had **no output** at all.
But it did perform the desired action, which we can see by 
checking the working directory again with `pwd`:

```bash
pwd
```
```bash-out
/fs/scratch/PAS2880/ENT6703/share
```

::: callout-note
#### I will demonstrate a neat feature called "tab completion"!
:::

In more abstract terms, you provided `cd` with an **argument** above,
namely the path of the dir to move to.
Arguments generally tell commands what file or directory to operate on.

So, `cd` gives no output when it succesfully changed the working directory.
But let's also see what happens when it does not succeed — it gives an error:

```bash
cd /fs/Scratch/PAS2880
```
```bash-out
bash: cd: /fs/Scratch/PAS2880: No such file or directory
```

<details><summary>{{< fa comments >}} What was the problem with the path we specified? *(Click to see the answer)*</summary>

We used a capital S in `/Scratch/` — this should have been `/scratch/`.

Everything in the shell is **case-sensitive**, including commands and file names.
So if a directory is called `scratch`, typing `Scratch` will not work!
</details>

### `ls` and command options

#### The default behavior of `ls`

The `ls` command, short for "list", will list files and directories --
by default those present in your current working dir:

```bash
ls
```
``` bash-out
data  README.md
```

::: {.callout-tip collapse="true"}
#### Side note: `ls` output colors *(click to expand)*

The `ls` output shown above does not show the different colors you
should see in your shell, where:

- Entries in **[blue]{style="color: #0328fc"}** are directories (like `data` and `metadata` above)
- Entries in **black** are regular files (like `README.md` above)
- Entries in **[red]{style="color: #d92118"}** are compressed files (we'll see an example soon).

_(Though colors may vary depending on your terminal and color scheme settings.)_
:::

#### Options (to `ls`)

The way that `ls` shows the output can be changed using options.
In general, while arguments tell a command *what to operate on*,
options will *modify its behavior*.
For example, we can call `ls` with the **option `-l`**
(a dash followed by a lowercase L):

```bash
ls -l 
```
``` bash-out
total 17
drwxr-xr-x 5 jelmer PAS0471 4096 Jan 21 12:39 data
-rw-r--r-- 1 jelmer PAS0471 1502 Jan 22 11:04 README.md
```

Notice that it lists the same items as our first `ls` call above,
but **printed in a different format**:
one item per line, with additional information such as the last-modified
date and time, and the file sizes in bytes (to the left of the date).

Let's add another option, `-h`:

```bash
ls -l -h
```
``` bash-out
total 17K
drwxr-xr-x 5 jelmer PAS0471 4.0K Jan 21 12:39 data
-rw-r--r-- 1 jelmer PAS0471 1.5K Jan 22 11:04 README.md
```

<details><summary>{{< fa comments >}} What is different about the output, and what do you think that means? *(Click to see the answer)*</summary>

The only difference is in the format of the column reporting the sizes of the
items listed.

You now have "Human-readable filesizes" (hence `-h`),
where sizes on the scale of kilobytes will be shown with `K`s,
of megabytes with `M`s, and of gigabytes with `G`s.
Minor detail, but this can be quite useful especially for large files.
</details>

Conveniently, options can be "pasted together";
`ls -lh` is equivalent to `ls -l -h`:

```bash
ls -lh
```
``` bash-out
total 17K
drwxr-xr-x 5 jelmer PAS0471 4.0K Jan 21 12:39 data
-rw-r--r-- 1 jelmer PAS0471 1.5K Jan 22 11:04 README.md
```

#### Combining options and arguments

Arguments to `ls` should be **dirs or files to operate on**.
For example, if you wanted to see what's inside the `data` dir,
instead of inside your working dir, we could type:

```bash
ls data
```
``` bash-out
fastq  meta  ref
```

The `data` dir appears to contain three dirs with different kinds of data.
We'll talk in detail about that later, but for now,
take a look inside the `fastq` dir:

```bash
ls data/fastq
```
```bash-out
ERR10802863_R1.fastq.gz  ERR10802865_R2.fastq.gz  ERR10802868_R1.fastq.gz  ERR10802870_R2.fastq.gz  ERR10802875_R1.fastq.gz  ERR10802877_R2.fastq.gz  ERR10802880_R1.fastq.gz  ERR10802882_R2.fastq.gz  ERR10802885_R1.fastq.gz
ERR10802863_R2.fastq.gz  ERR10802866_R1.fastq.gz  ERR10802868_R2.fastq.gz  ERR10802871_R1.fastq.gz  ERR10802875_R2.fastq.gz  ERR10802878_R1.fastq.gz  ERR10802880_R2.fastq.gz  ERR10802883_R1.fastq.gz  ERR10802885_R2.fastq.gz
ERR10802864_R1.fastq.gz  ERR10802866_R2.fastq.gz  ERR10802869_R1.fastq.gz  ERR10802871_R2.fastq.gz  ERR10802876_R1.fastq.gz  ERR10802878_R2.fastq.gz  ERR10802881_R1.fastq.gz  ERR10802883_R2.fastq.gz  ERR10802886_R1.fastq.gz
ERR10802864_R2.fastq.gz  ERR10802867_R1.fastq.gz  ERR10802869_R2.fastq.gz  ERR10802874_R1.fastq.gz  ERR10802876_R2.fastq.gz  ERR10802879_R1.fastq.gz  ERR10802881_R2.fastq.gz  ERR10802884_R1.fastq.gz  ERR10802886_R2.fastq.gz
ERR10802865_R1.fastq.gz  ERR10802867_R2.fastq.gz  ERR10802870_R1.fastq.gz  ERR10802874_R2.fastq.gz  ERR10802877_R1.fastq.gz  ERR10802879_R2.fastq.gz  ERR10802882_R1.fastq.gz  ERR10802884_R2.fastq.gz
```

Ah, FASTQ files!
These contain the HTS reads you'll work with,
and you'll explore them in the second part of this lab.

Finally, you can **combine options and arguments**,
and let's do so take a closer look at the dir with FASTQ files —
now, the `-h` option is especially useful and allows you see that the FASTQ files
are 21-22 Mb in size:

```bash
ls -lh data/fastq
```
``` bash-out
total 941M
-rw-r--r-- 1 jelmer PAS0471 21M Jan 21 13:34 ERR10802863_R1.fastq.gz
-rw-r--r-- 1 jelmer PAS0471 22M Jan 21 13:34 ERR10802863_R2.fastq.gz
-rw-r--r-- 1 jelmer PAS0471 21M Jan 21 13:34 ERR10802864_R1.fastq.gz
-rw-r--r-- 1 jelmer PAS0471 22M Jan 21 13:34 ERR10802864_R2.fastq.gz
-rw-r--r-- 1 jelmer PAS0471 22M Jan 21 13:34 ERR10802865_R1.fastq.gz
-rw-r--r-- 1 jelmer PAS0471 22M Jan 21 13:34 ERR10802865_R2.fastq.gz
-rw-r--r-- 1 jelmer PAS0471 21M Jan 21 13:34 ERR10802866_R1.fastq.gz
-rw-r--r-- 1 jelmer PAS0471 22M Jan 21 13:34 ERR10802866_R2.fastq.gz
[...output truncated...]
```

::: exercise
#### {{< fa user-edit >}} Exercise: Practice with `ls`

List the files in the `data/ref` dir.
What are the file sizes?

<details><summary>*Click for the solution*</summary>
  
```bash
ls -lh data/ref
```
```bash-out
total 670M
-rw-r--r-- 1 jelmer PAS0471 547M Jan 20 22:34 GCF_016801865.2.fna
-rw-r--r-- 1 jelmer PAS0471 123M Jan 20 22:34 GCF_016801865.2.gtf
```
  
The `.fna` file (this is the genome assembly nucleotide FASTA file) is 547 Mb
(not bases but bytes!), and the `.gtf` file (this is the annotation file) is 123 Mb.
</details>
:::

::: exercise
#### {{< fa user-edit >}} Bonus Exercise: Paths

Earlier with `cd`, you used long paths like `/fs/scratch/PAS2880/ENT6703/share`.
Here, you used short ones like `data` and `data/fastq`.
What is the difference between these kinds of paths?
  
A) When you use `cd`, you have to use long paths, but with `ls` you can use short ones.
B) `data` and `data/fastq` are just shorter because they are closer to the
   root of the filesystem, so there are fewer dirs to travel through.
C) The long paths start from the root of the file system,
   while the short paths start from your current working dir.
D) The long paths are for directories, while the short paths are for files.
  
<details><summary>*Click for the solution*</summary>
  
The correct answer is `C`.
  
The long paths are called **absolute paths**,
and start from the root of the file system
(recognized by a leading slash like in `/fs/ess`).
Making an analogy with geographic locations,
you can think of these as GPS coordinates:
they always point to the same location, no matter where you currently are.
   
The short paths are **relative paths**, starting from your current working dir.
So, if your working dir is `/fs/scratch/PAS2880/ENT6703`,
then `data` is equivalent to `/fs/scratch/PAS2880/ENT6703/data`.
Continuing the geographic analogy, these are like giving directions
starting from your current location such as "take the second left".
   
</details>  
:::

### A few more general shell tips

- **Command history:** If you hit the <kbd>⇧</kbd> (up arrow) once,
  you'll retrieve your most recent command, and if you keep hitting it,
  you'll go further back.
  The<kbd>⇩</kbd> (down arrow) will go the other way: towards the present.

- Your **cursor** can be anywhere on a line (not just at the end)
  when you press <kbd>Enter</kbd> to execute a command!

- Anything that comes after a `#` is considered a **comment** instead of code!

  ``` bash
  # This entire line is a comment - you can run it and nothing will happen
  pwd    # 'pwd' will be executed but everything after the '#' is ignored
  ```
  ``` bash-out
  /fs/scratch/PAS2880/ENT6703/jelmer
  ```

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Exercise: Shell navigation practice

1. Move into your personal directory (the one you created a little while back),
   and then back into the `share` dir.

   <details><summary>*Click for the solution*</summary>
  
   - Move into your personal dir (replace `jelmer` with _your_ username):
  
     ```bash
     cd /fs/scratch/PAS2880/ENT6703/jelmer
     ```
    
   - Move back to `ENT6703`:
  
     ```bash
     cd /fs/scratch/PAS2880/ENT6703/share
     ```
   </details>

2. Use command history (arrows) to repeat the previous exercise without typing
   commands.
:::

::: exercise
#### {{< fa user-edit >}} Bonus Exercise: Advanced navigation

In the first question, did you perhaps find yourself wondering
how you can move up a level in the file system?
In a path, `..` denotes one level up,
so `../bla` means one level up and _then_ down into the `bla` directory.
  
Try to make use of this construct to move into your personal dir and back to
`share` again, instead of using the "full paths" like above.
_Hint: Tab completion after typing `../` can help you to orient yourself!_

<details><summary>*Click for the solution*</summary>
   
- Into your personal dir (replace `jelmer` with your own username):
     
  ```bash
  cd ../jelmer
  ```
     
- Back to `share`:
     
  ```bash 
  cd ../share
  ```
</details>
   
<details><summary>*Click to see a diagram of using `..`*</summary>
<hr style="height:1pt; visibility:hidden;" />

![](../img/paths3.png){fig-align="center" width="40%" fig-alt="A diagram showing the hierarchical structure of a file system with folders and subfolders." .lightbox}

</details>
:::
